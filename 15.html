<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title></title>
<script type="text/javascript" src="d2js.js"></script>
<script type="text/javascript" src="d2js_gl.js"></script>
<script type="text/javascript" src="model_witch.js"></script>
<script type="text/javascript" src="model_cat.js"></script>
<script type="text/javascript" src="model_swan.js"></script>
<script type="text/javascript" src="model_ground.js"></script>
<script type="text/javascript">

window.onload = d2js_onload;
window.onorientationchange = d2js_onorientationchange;
window.onresize = d2js_onresize;

var useGLSprite = true;

var useStereo = false;
var canvasWidth = 1024;
var useStereoTrans = true;
var stereoTrans = 0.2;
var stereoAngle = 1.5;

var glu;

var stereo;

var image_loaded = false;
var image_array = new Array();
var glt;

var shadowFrameBufferWidth = 1024 * 4; // 2の累乗
var shadowFrameBufferHeight = 512 * 4; // 2の累乗
var shadowFrameBuffer;

var mirrorFrameBufferWidth = 1024; // 2の累乗
var mirrorFrameBufferHeight = 512; // 2の累乗
var mirrorFrameBuffer;

var shadowmapShader;
//---- シェーダープログラムの変数ここから ----
var aVertexPositionShadowmap;
var uModelMatrixShadowmap;
var uLightMatrixShadowmap;
var uMirrorShadowmap;
//---- シェーダープログラムの変数ここまで ----

var sceneShader = new Array(2);
//---- シェーダープログラムの変数ここから ----
var aVertexPosition = new Array(2);
var aVertexNormal = new Array(2);
var aVertexColor;
var aTextureCoord;
var uModelMatrix = new Array(2);
var uViewProjMatrix = new Array(2);
var uTextureMatrixShadowmap = new Array(2);
var uLightMatrix = new Array(2);
var uInvModelMatrix = new Array(2);
var uLightPosition = new Array(2);
var uTolerance = new Array(2);
var uSamplerShadowmap = new Array(2);
var uSampler;
var uMirror = new Array(2);
//---- シェーダープログラムの変数ここまで ----

var mirrorShader;
//---- シェーダープログラムの変数ここから ----
var aVertexPositionMirror;
var aTextureCoordMirror;
var uOrthoMatrixMirror;
var uSamplerMirror;
var uAlphaMirror;
//---- シェーダープログラムの変数ここまで ----

var elapse = 0.0;
//---- シェーダープログラムの変数ここから ----
var uFrequencyX = new Array(2);
var uFrequencyY = new Array(2);
var uAmplitudeX = new Array(2);
var uAmplitudeY = new Array(2);
var uSpeedX = new Array(2);
var uSpeedY = new Array(2);
var uElapse = new Array(2);
var uFrequencyXMirror;
var uFrequencyYMirror;
var uAmplitudeXMirror;
var uAmplitudeYMirror;
var uSpeedXMirror;
var uSpeedYMirror;
var uElapseMirror;
//---- シェーダープログラムの変数ここまで ----

var model = new Array(4);

var shadowFlag;
var mirrorFlag;

var cameraX = 0.0;
var cameraY = 0.0;
var cameraZ = 7.5;
var lookX = 0.0;
var lookY = cameraY;
var lookZ = 0.0;
var lightX = -3.0;
var lightY = 7.5;
var lightZ = 3.5;
var transLightX;
var transLightY;
var transLightZ;

var groundY = 0.0;

var mouseDown = false;
var mouseX;
var mouseY;
var rotateX = 25.0;
var rotateY = 25.0;

function mySetLightPos(gl) {
  // モデルの回転に合わせて光源位置を変換
  glu.setIdentity();
  glu.translate(0.0, lookY, 0.0);
  glu.rotate(rotateX, 1, 0, 0);
  glu.rotate(rotateY, 0, 1, 0);
  glu.translate(0.0, -lookY, 0.0);
  if (mirrorFlag) {
    glu.transVector(lightX, groundY - (lightY - groundY), lightZ);
  } else {
    glu.transVector(lightX, lightY, lightZ);
  }
  transLightX = glu.transX();
  transLightY = glu.transY();
  transLightZ = glu.transZ();

  // 光源視点でのプロジェクション行列
  var fieldOfView = 60.0; // 視野角（度）
  var aspect = shadowFrameBufferWidth / shadowFrameBufferHeight; // 幅と高さの比率はフレームバッファのサイズに合わせる
  var zNear = 0.1; // 表示するオブジェクトの範囲（手前）
  var zFar = 100.0; // 表示するオブジェクトの範囲（奥）
  glu.setIdentity();
  glu.perspective(fieldOfView, aspect, zNear, zFar);
  var depthProjMatrix = glu.glMatrix();

  // 光源視点でのビュー行列
  glu.lookAt(transLightX, transLightY, transLightZ, lookX, lookY, lookZ, 0.0, 1.0, 0.0);
  var depthViewMatrix = glu.glMatrix();

  // 光源視点でのビュー×プロジェクション座標変換行列
  glu.set(glu.utMatrix(depthProjMatrix));
  glu.multiply(glu.utMatrix(depthViewMatrix));
  var depthViewProjMatrix = glu.glMatrix();

  // テクスチャ座標変換用行列
  glu.set([
    0.5, 0.0, 0.0, 0.5,
    0.0, 0.5, 0.0, 0.5,
    0.0, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.0, 1.0
  ]);
  glu.multiply(glu.utMatrix(depthProjMatrix));
  glu.multiply(glu.utMatrix(depthViewMatrix));
  var textureMatrixShadowmap = glu.glMatrix();

  shadowmapShader.use();
  gl.uniformMatrix4fv(uLightMatrixShadowmap, false, depthViewProjMatrix);
  for (var i = 0; i < 2; i++) {
    sceneShader[i].use();
    gl.uniformMatrix4fv(uLightMatrix[i], false, depthViewProjMatrix);
    gl.uniformMatrix4fv(uTextureMatrixShadowmap[i], false, textureMatrixShadowmap);
    gl.uniform3fv(uLightPosition[i], [transLightX, transLightY, transLightZ]);
  }
}

function myCreateFrameBufferObject(gl, width, height) {
  // フレームバッファ
  var frameBuffer = gl.createFramebuffer();

  // テクスチャバッファ
  var colorBuffer = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, colorBuffer);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  // 深度バッファ
  var depthBuffer = gl.createRenderbuffer();
  gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height); // レンダーバッファを深度バッファとして設定

  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorBuffer, 0);
  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);

  var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  if (status !== gl.FRAMEBUFFER_COMPLETE) {
    return null;
  }

  frameBuffer.colorBuffer = colorBuffer;
  frameBuffer.depthBuffer = depthBuffer;
  frameBuffer.width = width;
  frameBuffer.height = height;
  return frameBuffer;
}

function frameTime() {
  return image_loaded ? 1000 / 30/*フレーム*/ : 100;
}

function init() {
  window._USE_KEY = true;
  window._USE_MOUSE = true;
}

function start() {
  setCurrent("fuga_canvas");
  return true;
}

function paint(g) {
  g.setColor(g.getColorOfRGB(127, 127, 127));
  g.fillRect(0, 0, getWidth(), getHeight());

  g.setFont(24, "ＭＳ ゴシック");

  // テクスチャの読み込み
  if (isImageBusy()) {
    if (image_array.length > 1) {
      g.drawImage(image_array[image_array.length - 2], 0, 0);
    }
    g.setColor(g.getColorOfRGB(0, 0, 255));
    g.drawString("" + image_array.length + "/" + img_src.length + " loading...", 5, 30);
  } else if (image_array.length <= img_src.length) {
    var index = image_array.length;
    if (index == 0) {
      g.setColor(g.getColorOfRGB(0, 0, 255));
      g.drawString("1/" + img_src.length + " loading...", 5, 30);
    } else {
      g.drawImage(image_array[index - 1], 0, 0);
      g.setColor(g.getColorOfRGB(0, 0, 255));
      g.drawString("" + index + "/" + img_src.length + " loaded", 5, 30);
    }
    if (image_array.length < img_src.length) {
      image_array[index] = loadImage(img_src[index]);
    } else if (!image_loaded) {
      image_loaded = true;
      window.setTimeout(function() {
        setCurrent3D("hoge_canvas", "fuga_canvas", true);
      }, 100);
    }
  }
}

function init3D(gl, _glu) {
  var i;

  if (gl.getExtension('WEBGL_depth_texture') == null) {
    return false;
  }

  glu = _glu;

  if (useStereo) {
    setCanvasSize(canvasWidth, getHeight());
    setCanvas3DSize(canvasWidth, getHeight());

    stereo = new _GLStereo(0.0, 0.0, getWidth(), getHeight());
  }

  glt = new _GLTexture(image_array, 3);

  // バッファの構築
  shadowFrameBuffer = myCreateFrameBufferObject(gl, shadowFrameBufferWidth, shadowFrameBufferHeight);
  mirrorFrameBuffer = myCreateFrameBufferObject(gl, mirrorFrameBufferWidth, mirrorFrameBufferHeight);

  const vsSourceShadowmap = `
    attribute vec3 aVertexPosition;

    uniform mat4 uModelMatrix;
    uniform mat4 uLightMatrix;
    uniform int uMirror;

    void main(void) {
      vec3 position = aVertexPosition;
      if (bool(uMirror)) {
        position = vec3(position.x, -position.y, position.z);
      }
      position = (uModelMatrix * vec4(position, 1.0)).xyz;
      gl_Position = uLightMatrix * vec4(position, 1.0);
    }
  `;
  const fsSourceShadowmap = `
    precision mediump float;

    void main(void) {
      float z = gl_FragCoord.z;
      float r = clamp((z - 0.75) * 4.0, 0.0, 1.0);
      float g = clamp((z - 0.5 ) * 4.0, 0.0, 1.0);
      float b = clamp((z - 0.25) * 4.0, 0.0, 1.0);
      float a = clamp((z - 0.0 ) * 4.0, 0.0, 1.0);
      gl_FragColor = vec4(r, g, b, a);
    }
  `;
  shadowmapShader = new _GLShader(vsSourceShadowmap, fsSourceShadowmap);
  //---- シェーダープログラムの変数ここから ----
  aVertexPositionShadowmap = shadowmapShader.attrib("aVertexPosition");
  uModelMatrixShadowmap = shadowmapShader.uniform("uModelMatrix");
  uLightMatrixShadowmap = shadowmapShader.uniform("uLightMatrix");
  uMirrorShadowmap = shadowmapShader.uniform("uMirror");
  //---- シェーダープログラムの変数ここまで ----

  const vsSourceScene = `
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec4 aVertexColor;

    uniform mat4 uModelMatrix;
    uniform mat4 uViewProjMatrix;
    uniform mat4 uTextureMatrixShadowmap;
    uniform mat4 uLightMatrix;
    uniform int uMirror;

    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec4 vColor;
    varying vec4 vTextureCoordShadowmap;
    varying vec4 vDepth;

    void main(void) {
      vec3 position = aVertexPosition;
      vec3 normal = aVertexNormal;
      if (bool(uMirror)) {
        position = vec3(position.x, -position.y, position.z);
        normal = vec3(normal.x, -normal.y, normal.z);
      }
      vPosition = (uModelMatrix * vec4(position, 1.0)).xyz;
      vNormal = normal;
      vColor = aVertexColor;
      vTextureCoordShadowmap = uTextureMatrixShadowmap * vec4(vPosition, 1.0);
      vDepth = uLightMatrix * vec4(vPosition, 1.0);
      gl_Position = uViewProjMatrix * vec4(vPosition, 1.0);
    }
  `;
  const fsSourceScene = `
    precision mediump float;

    uniform mat4 uInvModelMatrix;
    uniform vec3 uLightPosition;
    uniform float uTolerance;
    uniform sampler2D uSamplerShadowmap;

    uniform float uFrequencyX, uFrequencyY; // 波の頻度
    uniform float uAmplitudeX, uAmplitudeY; // 揺れ幅
    uniform float uSpeedX, uSpeedY; // 揺れのスピード
    uniform float uElapse; // 経過時間

    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec4 vColor;
    varying vec4 vTextureCoordShadowmap;
    varying vec4 vDepth;

    void main(void) {
      vec3 light = uLightPosition - vPosition;
      vec3 invLight = normalize(uInvModelMatrix * vec4(light, 0.0)).xyz;
      float diffuse = clamp(dot(vNormal, invLight), 0.2, 1.0);

      float offsetX = 0.0;
      if (uFrequencyX != 0.0) {
        offsetX = sin(gl_FragCoord.x * uFrequencyX + uElapse * uSpeedX) * uAmplitudeX;
      }
      float offsetY = 0.0;
      if (uFrequencyY != 0.0) {
        offsetY = cos(gl_FragCoord.y * uFrequencyY + uElapse * uSpeedY) * uAmplitudeY;
      }
      vec4 textureCoordShadowmap = vec4(vTextureCoordShadowmap.x + offsetX, vTextureCoordShadowmap.y + offsetY, vTextureCoordShadowmap.z, vTextureCoordShadowmap.w);

      vec4 depthColor = vec4(1.0);
      if (vDepth.w > 0.0) {
        vec4 lightCoord = vDepth / vDepth.w;
        lightCoord = lightCoord * 0.5 + 0.5; // -1.0～1.0の値を0.0～1.0の値に変換
        vec4 color = texture2DProj(uSamplerShadowmap, textureCoordShadowmap);
        float z = (color.r + color.g + color.b + color.a) / 4.0;
        if (lightCoord.z > z + uTolerance) {
          depthColor = vec4(0.5, 0.5, 0.5, 1.0);
        }
      }
      gl_FragColor = vColor * vec4(vec3(diffuse), 1.0) * depthColor;
    }
  `;
  const vsSourceSceneTexture = `
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;

    uniform mat4 uModelMatrix;
    uniform mat4 uViewProjMatrix;
    uniform mat4 uTextureMatrixShadowmap;
    uniform mat4 uLightMatrix;
    uniform int uMirror;

    varying vec3 vPosition;
    varying vec3 vNormal;
    varying highp vec2 vTextureCoord;
    varying vec4 vTextureCoordShadowmap;
    varying vec4 vDepth;

    void main(void) {
      vec3 position = aVertexPosition;
      vec3 normal = aVertexNormal;
      if (bool(uMirror)) {
        position = vec3(position.x, -position.y, position.z);
        normal = vec3(normal.x, -normal.y, normal.z);
      }
      vPosition = (uModelMatrix * vec4(position, 1.0)).xyz;
      vNormal = normal;
      vTextureCoord = aTextureCoord;
      vTextureCoordShadowmap = uTextureMatrixShadowmap * vec4(vPosition, 1.0);
      vDepth = uLightMatrix * vec4(vPosition, 1.0);
      gl_Position = uViewProjMatrix * vec4(vPosition, 1.0);
    }
  `;
  const fsSourceSceneTexture = `
    precision mediump float;

    uniform mat4 uInvModelMatrix;
    uniform vec3 uLightPosition;
    uniform float uTolerance;
    uniform sampler2D uSamplerShadowmap;
    uniform sampler2D uSampler;

    uniform float uFrequencyX, uFrequencyY; // 波の頻度
    uniform float uAmplitudeX, uAmplitudeY; // 揺れ幅
    uniform float uSpeedX, uSpeedY; // 揺れのスピード
    uniform float uElapse; // 経過時間

    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec2 vTextureCoord;
    varying vec4 vTextureCoordShadowmap;
    varying vec4 vDepth;

    void main(void) {
      //vec3 light = uLightPosition - vPosition;
      //vec3 invLight = normalize(uInvModelMatrix * vec4(light, 0.0)).xyz;
      //float diffuse = clamp(dot(vNormal, invLight), 0.2, 1.0);

      float offsetX = 0.0;
      if (uFrequencyX != 0.0) {
        offsetX = sin(gl_FragCoord.x * uFrequencyX + uElapse * uSpeedX) * uAmplitudeX;
      }
      float offsetY = 0.0;
      if (uFrequencyY != 0.0) {
        offsetY = cos(gl_FragCoord.y * uFrequencyY + uElapse * uSpeedY) * uAmplitudeY;
      }
      vec4 textureCoordShadowmap = vec4(vTextureCoordShadowmap.x + offsetX, vTextureCoordShadowmap.y + offsetY, vTextureCoordShadowmap.z, vTextureCoordShadowmap.w);

      vec4 depthColor = vec4(1.0);
      if (vDepth.w > 0.0) {
        vec4 lightCoord = vDepth / vDepth.w;
        lightCoord = lightCoord * 0.5 + 0.5; // -1.0～1.0の値を0.0～1.0の値に変換
        vec4 color = texture2DProj(uSamplerShadowmap, textureCoordShadowmap);
        float z = (color.r + color.g + color.b + color.a) / 4.0;
        if (lightCoord.z > z + uTolerance) {
          depthColor = vec4(0.5, 0.5, 0.5, 1.0);
        }
      }
      highp vec4 color = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
      //gl_FragColor = color * vec4(vec3(diffuse), 1.0) * depthColor;
      gl_FragColor = color * depthColor;
    }
  `;
  sceneShader[0] = new _GLShader(vsSourceScene, fsSourceScene);
  sceneShader[1] = new _GLShader(vsSourceSceneTexture, fsSourceSceneTexture);
  //---- シェーダープログラムの変数ここから ----
  for (i = 0; i < 2; i++) {
    aVertexPosition[i] = sceneShader[i].attrib("aVertexPosition");
    aVertexNormal[i] = sceneShader[i].attrib("aVertexNormal");
    if (i == 0) {
      aVertexColor = sceneShader[i].attrib("aVertexColor");
    } else {
      aTextureCoord = sceneShader[i].attrib("aTextureCoord");
    }
    uModelMatrix[i] = sceneShader[i].uniform("uModelMatrix");
    uViewProjMatrix[i] = sceneShader[i].uniform("uViewProjMatrix");
    uTextureMatrixShadowmap[i] = sceneShader[i].uniform("uTextureMatrixShadowmap");
    uLightMatrix[i] = sceneShader[i].uniform("uLightMatrix");
    uInvModelMatrix[i] = sceneShader[i].uniform("uInvModelMatrix");
    uLightPosition[i] = sceneShader[i].uniform("uLightPosition");
    uTolerance[i] = sceneShader[i].uniform("uTolerance");
    uSamplerShadowmap[i] = sceneShader[i].uniform("uSamplerShadowmap");
    if (i == 1) {
      uSampler = sceneShader[i].uniform("uSampler");
    }
    uMirror[i] = sceneShader[i].uniform("uMirror");

    uFrequencyX[i] = sceneShader[i].uniform('uFrequencyX');
    uFrequencyY[i] = sceneShader[i].uniform('uFrequencyY');
    uAmplitudeX[i] = sceneShader[i].uniform('uAmplitudeX');
    uAmplitudeY[i] = sceneShader[i].uniform('uAmplitudeY');
    uSpeedX[i] = sceneShader[i].uniform('uSpeedX');
    uSpeedY[i] = sceneShader[i].uniform('uSpeedY');
    uElapse[i] = sceneShader[i].uniform('uElapse');
  }
  //---- シェーダープログラムの変数ここまで ----

  var vsSourceMirror = `
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;

    uniform mat4 uOrthoMatrix;

    varying vec2 vTextureCoord;

    void main(void) {
      gl_Position = uOrthoMatrix * vec4(aVertexPosition, 1.0);

      vTextureCoord = aTextureCoord;
    }
  `;
  var fsSourceMirror = `
    precision mediump float;

    uniform sampler2D uSampler;
    uniform float uAlpha;

    uniform float uFrequencyX, uFrequencyY; // 波の頻度
    uniform float uAmplitudeX, uAmplitudeY; // 揺れ幅
    uniform float uSpeedX, uSpeedY; // 揺れのスピード
    uniform float uElapse; // 経過時間

    varying vec2 vTextureCoord;

    void main(void) {
      float offsetX = 0.0;
      if (uFrequencyX != 0.0) {
        offsetX = sin(gl_FragCoord.x * uFrequencyX + uElapse * uSpeedX) * uAmplitudeX;
      }
      float offsetY = 0.0;
      if (uFrequencyY != 0.0) {
        offsetY = cos(gl_FragCoord.y * uFrequencyY + uElapse * uSpeedY) * uAmplitudeY;
      }
      vec4 color = texture2D(uSampler, vec2(vTextureCoord.x + offsetX, vTextureCoord.y + offsetY));
      gl_FragColor = vec4(color.rgb, uAlpha);
    }
  `;
  mirrorShader = new _GLShader(vsSourceMirror, fsSourceMirror);
  //---- シェーダープログラムの変数ここから ----
  aVertexPositionMirror = mirrorShader.attrib('aVertexPosition');
  aTextureCoordMirror = mirrorShader.attrib('aTextureCoord');
  uOrthoMatrixMirror = mirrorShader.uniform('uOrthoMatrix');
  uSamplerMirror = mirrorShader.uniform('uSampler');
  uAlphaMirror = mirrorShader.uniform('uAlpha');
  //---- シェーダープログラムの変数ここまで ----

  //---- シェーダープログラムの変数ここから ----
  uFrequencyXMirror = mirrorShader.uniform('uFrequencyX');
  uFrequencyYMirror = mirrorShader.uniform('uFrequencyY');
  uAmplitudeXMirror = mirrorShader.uniform('uAmplitudeX');
  uAmplitudeYMirror = mirrorShader.uniform('uAmplitudeY');
  uSpeedXMirror = mirrorShader.uniform('uSpeedX');
  uSpeedYMirror = mirrorShader.uniform('uSpeedY');
  uElapseMirror = mirrorShader.uniform('uElapse');
  //---- シェーダープログラムの変数ここまで ----

  model[0] = createGLModel(model_witch, 0.015, 0, true, false);
  model[1] = createGLModel(model_cat, 0.005, 1, true, false);
  model[2] = createGLModel(model_swan, 0.005, 2, true, false);
  model[3] = createGLModel(model_ground, 0.033, 3, true, false);

  // プロジェクション行列
  var fieldOfView = 45.0; // 視野角（度）
  var aspect = getWidth() / getHeight(); // 幅と高さの比率はキャンバスの表示サイズに合わせる
  var zNear = 0.1; // 表示するオブジェクトの範囲（手前）
  var zFar = 100.0; // 表示するオブジェクトの範囲（奥）
  glu.setIdentity();
  glu.perspective(fieldOfView, aspect, zNear, zFar);
  var projMatrix = glu.glMatrix();
  if (useStereo) {
    stereo.setProjectionMatrix(projMatrix);
  }

  // ビュー行列
  glu.lookAt(cameraX, cameraY, cameraZ, lookX, lookY, lookZ, 0.0, 1.0, 0.0);
  var viewMatrix = glu.glMatrix();
  if (useStereo && !useStereoTrans) {
    stereo.setViewMatrix(viewMatrix, stereoAngle);
  }

  // ビュー×プロジェクション座標変換行列
  glu.set(glu.utMatrix(projMatrix));
  glu.multiply(glu.utMatrix(viewMatrix));
  var viewProjMatrix = glu.glMatrix();

  for (i = 0; i < 2; i++) {
    sceneShader[i].use();
    gl.uniformMatrix4fv(uViewProjMatrix[i], false, viewProjMatrix);
    gl.uniform1f(uTolerance[i], 0.001); // 1/1024(=0.00097)より大きい値
    gl.uniform1i(uSamplerShadowmap[i], 0/*TEXTURE0*/);
    if (i == 1) {
      gl.uniform1i(uSampler, 1/*TEXTURE1*/);
    }
    gl.uniform1f(uFrequencyX[i], 0.1); // 波のX方向頻度
    gl.uniform1f(uFrequencyY[i], 0.1); // 波のY方向頻度
    gl.uniform1f(uAmplitudeX[i], 0.005); // X方向揺れ幅
    gl.uniform1f(uAmplitudeY[i], 0.005); // Y方向揺れ幅
    gl.uniform1f(uSpeedX[i], 0.5); // X方向の揺れのスピード
    gl.uniform1f(uSpeedY[i], 0.5); // Y方向の揺れのスピード
  }
  mirrorShader.use();
  gl.uniform1f(uFrequencyXMirror, 0.1); // 波のX方向頻度
  gl.uniform1f(uFrequencyYMirror, 0.1); // 波のY方向頻度
  gl.uniform1f(uAmplitudeXMirror, 0.001); // X方向揺れ幅
  gl.uniform1f(uAmplitudeYMirror, 0.001); // Y方向揺れ幅
  gl.uniform1f(uSpeedXMirror, 0.5); // X方向の揺れのスピード
  gl.uniform1f(uSpeedYMirror, 0.5); // Y方向の揺れのスピード

  mySetLightPos(gl);

  return true;
}

function init2D(g) {
}

function clear2D(g) {
  g.setColor(g.getColorOfRGBA(0, 0, 0, 0));
  g.fillRect(0, 0, getWidth(), getHeight());
}

function paint3D(gl, glu) {
  // 経過時間
  elapse += 1.0;
  sceneShader[0].use();
  gl.uniform1f(uElapse[0], elapse);
  sceneShader[1].use();
  gl.uniform1f(uElapse[1], elapse);
  mirrorShader.use();
  gl.uniform1f(uElapseMirror, elapse);

  var key = getKeypadState();
  if ((key & keyBit(window._KEY_UP   )) != 0) { lightY += 0.1; }
  if ((key & keyBit(window._KEY_DOWN )) != 0) { lightY -= 0.1; }
  if ((key & keyBit(window._KEY_LEFT )) != 0) { lightX -= 0.1; }
  if ((key & keyBit(window._KEY_RIGHT)) != 0) { lightX += 0.1; }
  if ((key & keyBit(window._KEY_Z    )) != 0) { lightZ += 0.1; }
  if ((key & keyBit(window._KEY_X    )) != 0) { lightZ -= 0.1; }

  gl.enable(gl.CULL_FACE); // 裏面を表示しない

  gl.enable(gl.DEPTH_TEST); // 深度テストを有効化
  gl.depthFunc(gl.LEQUAL); // 奥にあるものは隠れるようにする
  gl.depthMask(true);

  if (useStereo) {
    stereo.draw();
  } else {
    myDraw(gl);
  }
}
function myDraw(gl) {
  // ステップ1：上下反転のモデルをフレームバッファに
  mirrorFlag = true;
  mySetLightPos(gl);
  myDrawScene(gl);

  // ステップ2：通常描画
  mirrorFlag = false;
  mySetLightPos(gl);
  myDrawScene(gl);

  // ステップ3：反射面の板を描画、ステンシルバッファに書き込む
  myDrawGround(gl);

  // ステップ4：テクスチャバッファに描画されたシーンを、画面全体に描画
  myDrawTexture(gl);
}
function myDrawScene(gl) {
  var gld;

  // ステンシルテストの無効化
  gl.disable(gl.STENCIL_TEST);

  if (mirrorFlag) {
    // カリング面の反転
    gl.cullFace(gl.FRONT);
  }

  // フレームバッファをバインド
  gl.bindFramebuffer(gl.FRAMEBUFFER, shadowFrameBuffer);

  // フレームバッファを初期化
  gl.clearColor(1.0, 1.0, 1.0, 1.0);
  gl.clearDepth(1.0);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // 描画領域を伝える
  glu.viewport(0.0, 0.0, shadowFrameBufferWidth, shadowFrameBufferHeight);

  // 反射面の板を除くモデルの描画
  gld = new _GLDraw(null);
  gld.add(model[0], -1, -1, null, -1);
  gld.add(model[1], -1, -1, null, -1);
  gld.add(model[2], -1, -1, null, -1);
  //gld.add(model[3], -1, -1, null, -1);
  shadowFlag = true;
  gld.draw(glt);

  // フレームバッファのバインドを解除
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  // フレームバッファをテクスチャとしてバインド
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, shadowFrameBuffer.colorBuffer);

  if (mirrorFlag) {
    // フレームバッファをバインド
    gl.bindFramebuffer(gl.FRAMEBUFFER, mirrorFrameBuffer);

    // フレームバッファを初期化
    gl.clearColor(0.0, 0.0, 1.0, 1.0);
    gl.clearDepth(1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // 描画領域を伝える
    glu.viewport(0.0, 0.0, mirrorFrameBufferWidth, mirrorFrameBufferHeight);
  } else {
    // ステンシル設定
    gl.enable(gl.STENCIL_TEST);
    gl.stencilFunc(gl.ALWAYS, 1, ~0);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);

    // 初期化
    gl.clearColor(0.0, 0.0, 1.0, 1.0);
    gl.clearDepth(1.0);
    gl.clearStencil(0);
    if (useStereo) {
      stereo.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
    } else {
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
    }

    // 描画領域を伝える
    if (useStereo) {
      stereo.viewport();
    } else {
      glu.viewport(0.0, 0.0, getWidth(), getHeight());
    }
  }

  // 反射面の板を除くモデルの描画
  gld = new _GLDraw(null);
  gld.add(model[0], -1, -1, null, -1);
  gld.add(model[1], -1, -1, null, -1);
  gld.add(model[2], -1, -1, null, -1);
  //gld.add(model[3], -1, -1, null, -1);
  shadowFlag = false;
  gld.draw(glt);

  if (mirrorFlag) {
    // カリング面を元に戻す
    gl.cullFace(gl.BACK);

    // フレームバッファのバインドを解除
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }
}
function myDrawGround(gl) {
  // ステンシル設定
  gl.enable(gl.STENCIL_TEST);
  gl.stencilFunc(gl.ALWAYS, 1, ~0);
  gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);

  // 反射面の板を描画する
  var gld = new _GLDraw(null);
  gld.add(model[3], -1, -1, null, -1);
  gld.draw(glt);
}
function myDrawTexture(gl) {
  // プログラムオブジェクトの選択
  mirrorShader.use();

  // 正射影用の座標変換行列
  glu.lookAt(0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
  var tmpMatrix = glu.glMatrix();
  glu.setIdentity();
  glu.ortho(-1.0, 1.0, 1.0, -1.0, 0.1, 1.0);
  glu.multiply(glu.utMatrix(tmpMatrix));
  gl.uniformMatrix4fv(uOrthoMatrixMirror, false, glu.glMatrix());

  gl.uniform1i(uSamplerMirror, 0);
  gl.uniform1f(uAlphaMirror, 0.5); // 透明度

  // 透明度に対応
  gl.enable(gl.BLEND);
  gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);

  // ステンシル設定
  gl.enable(gl.STENCIL_TEST);
  gl.stencilFunc(gl.EQUAL, 1, ~0);
  gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);

if (useGLSprite) {
  const positions = [
    -1.0,  1.0, 0.0, // 左上
     1.0,  1.0, 0.0, // 右上
    -1.0, -1.0, 0.0, // 左下
     1.0, -1.0, 0.0, // 右下
  ];
  const textureCoordinates = [
    0.0, 0.0, // 左上
    1.0, 0.0, // 右上
    0.0, 1.0, // 左下
    1.0, 1.0, // 右下
  ];
  var gls = new _GLSprite(-1, false);
  gls.setCoord(positions);
  gls.setMap(textureCoordinates, true);
  gls.draw(null, -1, false);
} else {
  // 画面全体を覆う板ポリゴンの構築
  const positions = [
    -1.0,  1.0, 0.0, // 左上
     1.0,  1.0, 0.0, // 右上
    -1.0, -1.0, 0.0, // 左下
     1.0, -1.0, 0.0, // 右下
  ];
  var positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
  gl.vertexAttribPointer(aVertexPositionMirror, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(aVertexPositionMirror);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  const textureCoordinates = [
    0.0, 0.0, // 左上
    1.0, 0.0, // 右上
    0.0, 1.0, // 左下
    1.0, 1.0, // 右下
  ];
  var textureCoordBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);
  gl.vertexAttribPointer(aTextureCoordMirror, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(aTextureCoordMirror);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // テクスチャの設定
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, mirrorFrameBuffer.colorBuffer);

  // 描画
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}
}

function paint2D(g) {
  g.setFont(24, "ＭＳ ゴシック");
  g.setColor(g.getColorOfRGB(255, 0, 255));
  g.drawString("rotateX " + rotateX, 0, 24);
  g.drawString("rotateY " + rotateY, 0, 48);
  g.drawString("lightX " + lightX, 0, 72);
  g.drawString("lightY " + lightY, 0, 96);
  g.drawString("lightZ " + lightZ, 0, 120);
}

// _GLModel用
function glModelActiveTexture(gl, id) {
  return gl.TEXTURE1;
}
function glModelBindPositionBuffer(gl, id) {
  if (shadowFlag) {
    if (id == 0) {
      _GLShader.bindPositionBuffer(aVertexPositionShadowmap[1]);
    } else {
      _GLShader.bindPositionBuffer(aVertexPositionShadowmap[0]);
    }
  } else {
    if (id == 0) {
      _GLShader.bindPositionBuffer(aVertexPosition[1]);
    } else {
      _GLShader.bindPositionBuffer(aVertexPosition[0]);
    }
  }
}
function glModelBindNormalBuffer(gl, id) {
  if (shadowFlag) {
  } else {
    if (id == 0) {
      _GLShader.bindNormalBuffer(aVertexNormal[1]);
    } else {
      _GLShader.bindNormalBuffer(aVertexNormal[0]);
    }
  }
}
function glModelBindColorBuffer(gl, id) {
  if (shadowFlag) {
  } else {
    if (id != 0) {
      _GLShader.bindColorBuffer(aVertexColor);
    }
  }
}
function glModelBindTextureCoordBuffer(gl, id) {
  if (shadowFlag) {
  } else {
    if (id == 0) {
      _GLShader.bindTextureCoordBuffer(aTextureCoord);
    }
  }
}
function glModelSetTexture(gl, glt/*_GLTexture*/, index, tex_index) {
  return false;
}
function glModelBeginDraw(gl, glt/*_GLTexture*/, index, tex_index) {
  return true;
}
function glModelEndDraw(gl, glt/*_GLTexture*/, index, tex_index) {
}

// _GLTexture用
function glTextureAlphaFlag(index) {
  return true;
}
function glTextureDepthFlag(index) {
  return true;
}
function glTextureFlipY(index) {
  return false;
}
function glTextureFilter(gl, index) {
  return gl.LINEAR;
}
function glTextureWrap(gl, index) {
  return gl.REPEAT;
}

// _GLDraw用
function glDrawUseProgram(gl, p, index) {
  if (shadowFlag) {
    // シャドウマップ用プログラムオブジェクトの選択
    shadowmapShader.use();
  } else {
    // プログラムオブジェクトの選択
    var i = (p.id() == 0) ? 1 : 0;
    sceneShader[i].use();

    if (p.id() == 3) {
      // 反射面の板の場合、影の揺れを設定する
      gl.uniform1f(uFrequencyX[i], 0.1);
      gl.uniform1f(uFrequencyY[i], 0.1);
    } else {
      // 反射面の板でない場合、影の揺れを無くす
      gl.uniform1f(uFrequencyX[i], 0.0);
      gl.uniform1f(uFrequencyY[i], 0.0);
    }
  }
}
function glDrawSetProjectionMatrix(gl, mat, p, index) {
}
function glDrawSetModelViewMatrix(gl, mat, p, index) {
  glu.push();

  // モデル行列
  glu.setIdentity();
  glu.translate(0.0, lookY, 0.0);
  glu.rotate(rotateX, 1, 0, 0);
  glu.rotate(rotateY, 0, 1, 0);
  glu.translate(0.0, -lookY, 0.0);
  if (p.id() == 0) {
    if (mirrorFlag) {
      glu.translate(0.0, groundY - (0.05 - groundY), 0.0);
    } else {
      glu.translate(0.0, 0.05, 0.0);
    }
  }
  if (p.id() == 1) {
    if (mirrorFlag) {
      glu.translate(-1.5, groundY - (0.4 - groundY), 0.5);
    } else {
      glu.translate(-1.5, 0.4, 0.5);
    }
  }
  if (p.id() == 2) {
    if (mirrorFlag) {
      glu.translate(2.0, groundY - (2.0 - groundY), 0.5);
    } else {
      glu.translate(2.0, 2.0, 0.5);
    }
  }
  if (p.id() == 3) {
    glu.translate(0.0, groundY, 0.0);
  }
  var modelMatrix = glu.glMatrix();

  if (shadowFlag) {
    gl.uniformMatrix4fv(uModelMatrixShadowmap, false, modelMatrix);

    gl.uniform1i(uMirrorShadowmap, mirrorFlag);
  } else {
    var i = (p.id() == 0) ? 1 : 0;

    gl.uniformMatrix4fv(uModelMatrix[i], false, modelMatrix);

    // 逆行列
    glu.invert();
    gl.uniformMatrix4fv(uInvModelMatrix[i], false, glu.glMatrix());

    gl.uniform1i(uMirror[i], mirrorFlag);
  }

  glu.pop();
}

// _GLSprite用
function glSpriteActiveTexture(gl, id) {
  return gl.TEXTURE0;
}
function glSpriteBindPositionBuffer(gl, id) {
  _GLShader.bindPositionBuffer(aVertexPositionMirror);
}
function glSpriteBindTextureCoordBuffer(gl, id) {
  _GLShader.bindTextureCoordBuffer(aTextureCoordMirror);
}
function glSpriteSetTexture(gl, glt/*_GLTexture*/, tex_index, id) {
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, mirrorFrameBuffer.colorBuffer);
  return true;
}

// _GLStereo用
function glStereoSetProjectionMatrix(gl, mat) {
}
function glStereoSetViewMatrix(gl, mat) {
  // ビュー×プロジェクション座標変換行列
  glu.set(glu.utMatrix(stereo.projectionMatrix()));
  glu.multiply(glu.utMatrix(mat));
  var viewProjMatrix = glu.glMatrix();

  for (var i = 0; i < 2; i++) {
    sceneShader[i].use();
    gl.uniformMatrix4fv(uViewProjMatrix[i], false, viewProjMatrix);
  }
}
function glStereoDraw(gl, glu, leftFlag) {
  if (useStereoTrans) {
    // ビュー行列
    if (leftFlag) {
      glu.lookAt(cameraX + stereoTrans, cameraY, cameraZ, lookX, lookY, lookZ, 0.0, 1.0, 0.0);
    } else {
      glu.lookAt(cameraX - stereoTrans, cameraY, cameraZ, lookX, lookY, lookZ, 0.0, 1.0, 0.0);
    }
    glStereoSetViewMatrix(gl, glu.glMatrix());
  }

  myDraw(gl);
}

function processEvent(type, param) {
  switch (type) {
  case window._MOUSE_DOWN_EVENT:
    mouseDown = true;
    mouseX = getMouseX();
    mouseY = getMouseY();
    break;
  case window._MOUSE_UP_EVENT:
    mouseDown = false;
    break;
  case window._MOUSE_MOVE_EVENT:
    if (mouseDown) {
      var newMouseX = getMouseX();
      var newMouseY = getMouseY();
      rotateX += (newMouseY - mouseY) / 2.0;
      rotateY += (newMouseX - mouseX) / 2.0;
      mouseX = newMouseX;
      mouseY = newMouseY;
    }
    break;
  }
}

function error() {
}

</script>
<style type="text/css">
html, body {
  margin:0;
  padding:0;
}
</style>
</head>
<body>
<div align="center">
  <div style="position:relative">
    <canvas id="hoge_canvas" style="position:absolute; left:50%; transform:translate(-50%, 0)" width="640" height="480"></canvas>
    <canvas id="fuga_canvas" style="position:absolute; left:50%; transform:translate(-50%, 0)" width="640" height="480"></canvas>
  </div>
</div>
</body>
</html>
